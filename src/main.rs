
fn main() {
    println!("running program!");
    customizing_builds_with_release_profiles();
    publishing_a_crate_to_crates_io();
    cargo_workspaces();
}

fn customizing_builds_with_release_profiles() {
    //Cargo has two main profiles: the `dev` profile which is run by default when running cargo
    // build and the `release` profile when cargo build --release is run.

    //Look in Cargo.toml for some more info on changing the profiles.
}

fn publishing_a_crate_to_crates_io() {
    /// This is a 'documentation comment' and when writing documentation for publishing things on
    /// crates.io, it is a good idea to use them. They are specifically for people interested in
    /// how to use the crate rather than how the crate is implemented.
    /// Documentation comments support markdown language. Some examples are below.
    pub fn dummy_func(arg: isize) -> isize {
        arg + 1
    }

    //There is an interesting feature that Rust allows. It will actually run the code inside the
    // documentation comments. This allows us to make sure the examples and such actually work.
    // However, in order for it to work it must be inside a library (this is the same restriction
    // that tests have in general).
    println!("doc_func: {}", rust_book_chapter_14::documented_function(5));
    println!("dummy_func: {}", dummy_func(5));

    //Documentation can be generated by running the cargo doc command. This will store the
    // documentation files inside target/doc directory. cargo doc --open can also be used to
    // conveniently see the documentation in HTML.

    //Called to avoid warnings. These are used as an example to expose documentation to the public
    // API.
    println!("remove_corners(): {:?}", rust_book_chapter_14::utils::remove_corners(rust_book_chapter_14::shapes::Corners::Rectangle));
    println!("remove_corners(): {:?}", rust_book_chapter_14::utils::remove_corners(rust_book_chapter_14::shapes::Corners::Square));

    //The next section goes over publishing a crate on crates.io. I am not going to publish a crate
    // on crates.io. The Cargo.toml file must have a few fields updated such as name and license.
    // After that, the command `cargo publish` can be run from the command line to publish the
    // crate. These crates can also be updated and have a version system associated with this. They
    // can not be removed after published, but they can be deprecated (specific versions can be
    // deprecated as well). The command to deprecate a crate is `cargo yank --vers 1.0`.

}

fn cargo_workspaces() {
    //A workspace is a set of packages that share the same Cargo.lock and output directory.

    //Made a workspace named `add` inside this project. The workspaces can have multiple libraries
    // within the same project. These workspaces share a Cargo.lock file, this allows them to all
    // use the same dependencies when necessary. For example, say an older version of rand is used
    // in one library. If the binary wants to use it too, I will need to include the crate in the
    // binaries Cargo.toml file, but it will not need to be downloaded again.

    //Each crate will need to be published separately to crates.io if publishing them.
}

fn installing_binaries_from_crates_io() {
    //The cargo install command allows to install and use binary crates locally. For example the
    // ripgrep command can be installed by using `cargo install ripgrep`. This will allow use from
    // the terminal of this command. On my system it puts them on `/home/jeremiah/.cargo/bin/rg`.
}

fn extending_cargo_with_custom_commands() {
    //The `cargo` terminal command can be extended. This can be done by adding a Rust binary to the
    // $PATH variable named cargo-something. This can then be run by using `cargo something`. This
    // allows for installing binaries with cargo install, then using them as built in Cargo tools.
}
